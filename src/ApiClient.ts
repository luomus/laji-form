import { Translations } from "./components/LajiForm";
import { Lang } from "./types";
import type { paths } from "generated/api"; // generated by openapi-typescript


type LajiApiErrorJSONContent = { message: string, statusCode: number };

export class LajiApiError extends Error {
	statusCode: number;
	constructor(message: string, statusCode: number) {
		super(message);
		this.statusCode = statusCode;
	}
}

interface Query {
	[param: string]: any;
}

export interface ApiClientImplementation {
	fetch: (path: string, query: Query, options: any) => Promise<Response>;
}

type RelaxQuery<P, K extends string> = P extends { query: infer Q }
	? Omit<P, "query"> & (
		Record<string, unknown> extends Omit<Q, Extract<keyof Q, K>>
			? { query?: Omit<Q, Extract<keyof Q, K>> & Partial<Pick<Q, Extract<keyof Q, K>>> }
			: { query: Omit<Q, Extract<keyof Q, K>> & Partial<Pick<Q, Extract<keyof Q, K>>> }
	)
	: P;

type MiddlewareInjectedKeys = "collectionID" | "formID" | "personToken";

type Parameters<T> = "parameters" extends keyof T ? T["parameters"] : never;
type ExtractContentIfExists<R> = R extends { content: infer C } ? C[keyof C] : null;
type ExtractRequestBodyIfExists<R> =
	R extends { requestBody: { content: infer C } } | { requestBody?: { content: infer C } }
		? C[keyof C]
		: never;
type HttpSuccessCodes = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 226;
type IntersectUnionTypes<A, B> = A extends B ? A : never;

type WithResponses<T> = T & { responses: unknown };

type Path = keyof paths & string;
type PathWithMethod<M extends string> =
	keyof { [P in keyof paths as paths[P] extends Record<M, any> ? P : never]: paths[P] };

type Method<P extends Path> = Exclude<
	keyof { [K in keyof paths[P] as paths[P][K] extends undefined | never ? never : K]: paths[P][K] }
	, "parameters">;
type Responses<P extends Path, M extends Method<P>> = WithResponses<paths[P][M]>["responses"];

const splitAndResolvePath = (path: string, params?: { path?: Record<string, string>, query?: Record<string, string | number | boolean> }): string[] => {
	// parse path into segments based on path parameters
	// eg. "/person/{personToken}/profile" -> ["/person", "/{personToken}", "/profile"]
	const segments = path.split(/(\/\{[^}]+\})/).filter(Boolean);

	if (!params) {
		return segments;
	}

	// resolve path parameters (eg. replace '/{personToken}' with params.path.personToken)
	for (let i = 1; i < segments.length; i++) {
		const segment = segments[i];
		segments[i] = segment.replace(/\{([^}]+)\}/, (match, p1) => (params as any)["path"][p1] ?? "");
	}

	return segments;
};

type CacheNode = { branches: Map<string, CacheNode>, queries: Map<string, Promise<any>>, path: string };

/**
 * ApiClient with automatically generated typings for laji-api. An `ApiClientImplementation` must be provided, that will
 * perform the actual requests. The implementation acts as a middleware for injecting access token and person token.
 *
 * Get requests are automatically cached, and they will flush if the resource receives a POST/PUT/DELETE request.
 */
export default class ApiClient {
	apiClient: ApiClientImplementation;
	lang: Lang = "en";
	translations: Translations;
	cacheTree: CacheNode = { branches: new Map<string, CacheNode>(), queries: new Map(), path: "" };
	on: {[path: string]: (() => void)[]} = {};

	constructor(apiClient: ApiClientImplementation, lang: Lang = "en", translations: Translations) {
		this.apiClient = apiClient;
		this.lang = lang;
		this.translations = translations;
	}

	private flush(path: string, params?: { path?: Record<string, string>, query?: Record<string, string | number | boolean> }) {
		const segments = splitAndResolvePath(path, params);
		let node: CacheNode = this.cacheTree;
		const nodesToFlush: CacheNode[] = [];

		for (let i = 0; i < segments.length; i++) {
			const segment = segments[i];
			if (node.branches.has(segment)) {
				node = node.branches.get(segment) as CacheNode;
				nodesToFlush.push(node);
			} else {
				break;
			}
		}

		for (let i = 0; i < nodesToFlush.length; i++) {
			const node = nodesToFlush[i];
			node.queries = new Map();
			this.on[node.path]?.forEach(fn => fn());
		}
	}

	private getCacheNode(path: string, params: { path?: Record<string, string>, query?: Record<string, string | number | boolean> }) {
		const segments = splitAndResolvePath(path, params);
		const serializedQuery = hashRecord(params?.query || {});
		let node: CacheNode = this.cacheTree;

		for (let i = 0; i < segments.length; i++) {
			const segment = segments[i];
			if (node.branches.has(segment)) {
				node = node.branches.get(segment) as CacheNode;
			} else {
				const newNode: CacheNode = { branches: new Map(), queries: new Map(), path: segments.join("") };
				node.branches.set(segment, newNode);
				node = newNode;
			}
			if (i === segments.length - 1) {
				continue;
			}
			if (node.queries.has(serializedQuery)) {
				return node;
			}
		}
		return node;
	};

	/** The response is cached until the resource receives a POST/PUT/DELETE request. */
	async get<P extends PathWithMethod<"get">, R extends Responses<P, "get" extends Method<P> ? "get" : never>>(
		path: P,
		params?: RelaxQuery<Parameters<paths[P]["get"]>, MiddlewareInjectedKeys>,
		/** Defaults to true */
		useCache = true
	): Promise<ExtractContentIfExists<R[IntersectUnionTypes<keyof R, HttpSuccessCodes>]>> {
		let cacheNode: CacheNode;
		let serializedQuery: string;
		if (useCache) {
			serializedQuery = hashRecord(params?.query);
			cacheNode = this.getCacheNode(path, params as any);

			if (cacheNode.queries.has(serializedQuery)) {
				return cacheNode.queries.get(serializedQuery);
			}
		}

		const result = this.fetch(path, "get" as any, params as any);
		if (useCache) {
			cacheNode!.queries = cacheNode!.queries;
			cacheNode!.queries.set(serializedQuery!, result);
		}
		return result;
	}

	/** Subscribe to a GET request. It re-emits when the resource receives a POST/PUT/DELETE request. */
	subscribe<P extends PathWithMethod<"get">, R extends Responses<P, "get" extends Method<P> ? "get" : never>>(
		path: P,
		params: RelaxQuery<Parameters<paths[P]["get"]>, MiddlewareInjectedKeys> | undefined,
		onFulfilled: (response: ExtractContentIfExists<R[IntersectUnionTypes<keyof R, HttpSuccessCodes>]>) => void,
		onError?: () => void,
		/**
		 * Store doesn't sync it's search indices right away after data is changed, so delaying the request can be useful
		 */
		delay?: number
	): () => void {
		if (!this.on[path]) this.on[path] = [];
		const fn = delay
			? () => { setTimeout(() => this.get(path, params).then(onFulfilled, onError), delay); }
			: () => { this.get(path, params).then(onFulfilled, onError); };
		this.on[path].push(fn);
		this.get(path, params).then(onFulfilled, onError);
		return () => {
			this.on[path] = this.on[path].filter(_fn => _fn !== fn);
		};
	}

	async put<P extends PathWithMethod<"put">, R extends Responses<P, "put" extends Method<P> ? "put" : never>>(
		path: P,
		params?: RelaxQuery<Parameters<paths[P]["put"]>, MiddlewareInjectedKeys>,
		body?: ExtractRequestBodyIfExists<paths[P]["put"]>
	): Promise<ExtractContentIfExists<R[IntersectUnionTypes<keyof R, HttpSuccessCodes>]>> {
		const result = await this.fetch(path, "put" as any, params as any, body);
		this.flush(path, params);
		return result;
	}

	async post<P extends PathWithMethod<"post">, R extends Responses<P, "post" extends Method<P> ? "post" : never>>(
		path: P,
		params?: RelaxQuery<Parameters<paths[P]["post"]>, MiddlewareInjectedKeys>,
		body?: ExtractRequestBodyIfExists<paths[P]["post"]>,
	): Promise<ExtractContentIfExists<R[IntersectUnionTypes<keyof R, HttpSuccessCodes>]>> {
		const result = this.fetch(path, "post" as any, params as any, body);
		this.flush(path, params);
		return result;
	}

	async delete<P extends PathWithMethod<"delete">, R extends Responses<P, "delete" extends Method<P> ? "delete" : never>>(
		path: P,
		params?: RelaxQuery<Parameters<paths[P]["delete"]>, MiddlewareInjectedKeys>
	): Promise<ExtractContentIfExists<R[IntersectUnionTypes<keyof R, HttpSuccessCodes>]>> {
		const result = this.fetch(path, "delete" as any, params as any);
		this.flush(path, params);
		return result;
	}

	/**
	 * Implementing apiClient must return a promise that passes the raw response as 1st arg.
	 * @param path URL for GET.
	 * @param query Object, where keys are param names and values are param values.
	 * @returns a Promise.
	 */
	async fetch<P extends Path, M extends Method<P>, R extends Responses<P, M>>(
		path: P,
		method: M,
		params?: Parameters<paths[P][M]>,
		body?: ExtractRequestBodyIfExists<paths[P][M]>,
		options: any = {}
	): Promise<ExtractContentIfExists<R[IntersectUnionTypes<keyof R, HttpSuccessCodes>]>> {
		const _query = { lang: this.lang, ...((params as any)?.query || {}) };
		if (!_query.lang) {
			delete (_query as any).lang;
		}
		const pathSegments = splitAndResolvePath(path, params);

		options = {
			...options,
			headers: {
				...(options.headers || {}),
				"API-Version": 1,
				"Accept-Language": this.lang
			}
		};
		if (body && !otherThanJSON(body)) {
			options = {
				...options,
				headers: { 
					...(options.headers || {}),
					"Content-Type": "application/json",
					"Accept": "application/json",
				}
			};
			body = JSON.stringify(body) as any;
		}

		const response = await this.apiClient.fetch(pathSegments.join(""), _query, { method, body, ...options });
		if (response.status >= 400) {
			const error: LajiApiErrorJSONContent = await response.json();
			throw new LajiApiError(error?.message, response.status);
		}
		return (response.headers.get("Content-Type") || "").includes("application/json")
			? response.json()
			: response.text() as any;
	}

	setLang(lang: Lang) {
		this.lang = lang;
		this.cacheTree = { branches: new Map<string, CacheNode>(), queries: new Map(), path: "" };
	}
}

const otherThanJSON = (body: any) => 
	body instanceof FormData ||
		body instanceof Blob ||
		body instanceof ArrayBuffer ||
		body instanceof URLSearchParams ||
		body instanceof ReadableStream;

function isRecord(value: unknown): value is Record<string, unknown> {
	return typeof value === "object" && value !== null && !Array.isArray(value);
}

const sortRecordRecursively = (record: Record<string, unknown>): Record<string, unknown> => (
	Object.entries(record)
		.sort(([aKey, aVal], [bKey, bVal]) => aKey > bKey ? 1 : aKey < bKey ? -1 : 0)
		.reduce((acc, [key, value]) => {
			acc[key] = isRecord(value) ? sortRecordRecursively(value) : value;
			return acc;
		}, Object.create(null))
);

const hashRecord = (record: any): string => JSON.stringify(sortRecordRecursively(record || {}));
